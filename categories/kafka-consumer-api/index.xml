<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kafka Consumer API on rmoff&#39;s random ramblings</title>
    <link>https://rmoff.net/categories/kafka-consumer-api/</link>
    <description>Recent content in Kafka Consumer API on rmoff&#39;s random ramblings</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 14 Jul 2020 13:59:05 +0100</lastBuildDate><atom:link href="https://rmoff.net/categories/kafka-consumer-api/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Learning Golang (some rough notes) - S02E04 - Kafka Go Consumer (Function-based)</title>
      <link>https://rmoff.net/2020/07/14/learning-golang-some-rough-notes-s02e04-kafka-go-consumer-function-based/</link>
      <pubDate>Tue, 14 Jul 2020 13:59:05 +0100</pubDate>
      
      <guid>https://rmoff.net/2020/07/14/learning-golang-some-rough-notes-s02e04-kafka-go-consumer-function-based/</guid>
      <description>Last time I looked at creating my first Apache Kafka consumer in Go, which used the now-deprecated channel-based consumer. Whilst idiomatic for Go, it has some issues which mean that the function-based consumer is recommended for use instead. So letâ€™s go and use it!
 Instead of reading from the Events() channel of the consumer, we read events using the Poll() function with a timeout. The way we handle events (a switch based on their type) is the same:</description>
    </item>
    
    <item>
      <title>Learning Golang (some rough notes) - S02E03 - Kafka Go Consumer (Channel-based)</title>
      <link>https://rmoff.net/2020/07/14/learning-golang-some-rough-notes-s02e03-kafka-go-consumer-channel-based/</link>
      <pubDate>Tue, 14 Jul 2020 11:59:05 +0100</pubDate>
      
      <guid>https://rmoff.net/2020/07/14/learning-golang-some-rough-notes-s02e03-kafka-go-consumer-channel-based/</guid>
      <description>&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Having written my first &lt;a href=&#34;https://rmoff.net/2020/07/08/learning-golang-some-rough-notes-s02e01-my-first-kafka-go-producer/&#34;&gt;Kafka producer in Go&lt;/a&gt;, and even &lt;a href=&#34;https://rmoff.net/2020/07/10/learning-golang-some-rough-notes-s02e02-adding-error-handling-to-the-producer/&#34;&gt;added error handling to it&lt;/a&gt;, the next step was to write a consumer. It follows closely the pattern of &lt;a href=&#34;https://rmoff.net/2020/07/10/learning-golang-some-rough-notes-s02e02-adding-error-handling-to-the-producer/&#34;&gt;Producer code I finished up with previously&lt;/a&gt;, using the channel-based approach for the &lt;a href=&#34;https://docs.confluent.io/current/clients/confluent-kafka-go/index.html#Consumer&#34;&gt;Consumer&lt;/a&gt;:&lt;/p&gt;
&lt;/div&gt;</description>
    </item>
    
  </channel>
</rss>
